---
title: "trade"
output: html_document
date: "2023-12-02"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(statnet)
library(stats)
library(ergm)
library(igraph)
```

```{r}
# making the distance network
dist <- read.csv("dist.csv",stringsAsFactors = FALSE)
#dist$log_dist <- log(dist$dist)
el_dist <- dist[dist[,1] != dist[,2], ] # removing self loops

#el_dist$concat <- apply(el_dist[, c("Ego", "Alter")], 1, function(x) paste(sort(x), collapse = "-"))

# Removing duplicates 
#undirected_dist <- el_dist[!duplicated(el_dist$concat), ]

dis_net <- network(el_dist, directed = TRUE, matrix.type = "edgelist",loops = FALSE)
set.edge.value(dis_net, "dist", el_dist$dist)
#set.edge.value(dis_net, "log_dist", el_dist$log_dist)
dis_net
```
```{r}
#class(dis_net$dist)
#summary(dis_net)
#class(dis_net %e% "dist")
```



```{r}
# making the colonization network
col <- read.csv("colonization_el.csv",stringsAsFactors = FALSE)
#dist$log_dist <- log(dist$dist)
col <- col[col[,1] != col[,2], ] # removing self loops
#col_col$concat <- apply(col[, c("Ego", "Alter")], 1, function(x) paste(sort(x), collapse = "-"))
# removing duplicates 
#undirected_dist <- el_dist[!duplicated(el_dist$concat), ]

col_net <- network(col, directed = TRUE, matrix.type = "edgelist",loops = FALSE)
col_net
set.edge.value(col_net, "colonization", col$colonization)
col_net
```

# Making continguity netword


```{r}
c <- read.csv("cont.csv",stringsAsFactors = FALSE)
#c[duplicated(c), ]
```
## removing duoplicated rows
```{r}
con <- unique(c)
```

```{r}
country_att <- read.csv("common.csv",header = TRUE, as.is = TRUE, stringsAsFactors = FALSE)
```


```{r}
library(dplyr)
```

# removing the rows with same coljumns and lowest third column value

```{r}
result <- con %>%
  group_by(Ego, Alter) %>%
  filter(conttype == min(conttype)) %>%
  ungroup()
```
# only keeping the countries those are in countries list


```{r}
countries <- read.csv("countries.csv",stringsAsFactors = FALSE)
result1 <- result[result$Ego %in% countries$country_iso3 | result$Alter %in% countries$country_iso3, ]
```

```{r}
result1[duplicated(result1), ]
```

```{r}
length(unique(result1$Ego))
```



```{r}
co <- network(result1, directed = FALSE, matrix.type = "edgelist", vertex.attr=country_att,  vertex.attrnames=colnames(country_att))
set.edge.value(co, "conttype", result1$conttype)
```

```{r}
co
```





```{r}
#plot(co, displaylabels=T, mode="circle")
```



```{r}
#Reference : https://cran.r-project.org/web/packages/intergraph/vignettes/howto.html#network-igraph
library(intergraph)
g <- asIgraph(co)
```



```{r}
summary(g)
mean(degree(g))
graph.density(g)
diameter(g)


reciprocity(g)
transitivity(g)
average.path.length(g)
```
```{r}
i_deg <- degree(g, mode="in") 
which(i_deg==max(i_deg))
```

```{r}
library(viridis)
unique_continents <- unique(country_att$continent)
colors <- magma(length(unique_continents))
node_colors <- colors[match(country_att$continent, unique_continents)]
```

```{r}
options(repr.plot.width = 15, repr.plot.height = 10)
# plotting the network with node colors based on coreness
plot(g, 
     vertex.size = strength(g, mode = "in")/2, #reducing the node size 
     vertex.color = node_colors, 
     vertex.label = V(g)$Ego,
     vertex.label.cex = 0.4,
     edge.arrow.size = 0.1, 
     edge.curved=TRUE, 
     layout = as.matrix(cbind(country_att$Longitude.average.,country_att$Latitude.average.)), asp = 0.5,
     edge.width = scales::rescale(E(g)$conttype, to = c(-1,2)),
     main = "Continguity Network")

```


# Service trade network

```{r}
s <- read.csv("service_2021.csv",stringsAsFactors = FALSE)
#only keeping the total services
filtered_s <- subset(s, SERVICE == "S")
filtered_s[duplicated(filtered_s), ]
filt <- unique(filtered_s)
```


# Service trade attributes

```{r}
node_attribute <- read.csv("service_attribute_2021.csv", header = TRUE, as.is = TRUE, stringsAsFactors= FALSE)
```


```{r}
#install.packages("imputeTS")
#library(imputeTS)
# mean imputation
#com$GDP <- na.mean(com$GDP)
#com$FDI_net_inflows <- na.mean(com$FDI_net_inflows)
#com$Inflation_rate <- na.mean(com$Inflation_rate)
#com$GDP_per_capita <- na.mean(com$GDP_per_capita)
#class(com$GDP)
#com$GDP <- as.numeric(com$GDP)
#com$Inflation_rate <- as.numeric(com$Inflation_rate)
#com$GDP_per_capita <- as.numeric(com$GDP_per_capita)
#com$FDI_net_inflows <- as.numeric(com$FDI_net_inflows)
#com$area <- as.numeric(com$area)
#sum(is.na(com$GDP))
#com$log_gdp <- log10(com$GDP)
#rm(filtered_s)
```


```{r}
filt <- filt[filt$Ego %in% node_attribute$Ego_x, ]
filt <- filt[filt$Alter %in% node_attribute$Ego_x, ]
```



```{r}
length(unique(filt$Ego))
length(unique(filt$Alter))
length(unique(node_attribute$Ego_x))
length(unique(node_attribute$Ego_x))
```
```{r}
egos_in_filt <- unique(filt$Ego)
alter_in_filt <- unique(filt$Alter)
egos_in_countries <- unique(node_attribute$Ego_x)
setdiff(egos_in_filt, egos_in_countries)
```

```{r}
attribute <- read.csv("service_att_2021_filt.csv", header = TRUE, as.is = TRUE, stringsAsFactors= FALSE)
```


```{r}
setdiff(node_attribute$Ego_x, egos_in_filt)
```
```{r}
setdiff(alter_in_filt, attribute$Ego_x)
```

```{r}
# Filter rows where Alter is not in the specified values
filtered_nodes <- filt[!(filt$Alter %in% c("ZAF", "YEM", "ZMB", "ZWE")), ]

# Print or inspect the filtered nodes
length(unique(filtered_nodes$Ego))
length(unique(filtered_nodes$Alter))
```

```{r}
#write.csv(filtered_nodes, 'service_filt_2021.csv')
```


```{r}
se <- graph.data.frame(d = filtered_nodes, vertices = attribute, directed = TRUE)
edge_weights <- filtered_nodes$Value
E(se)$weight <- edge_weights
```

```{r}
top <- delete.edges(se, which(E(se)$Value < quantile(E(se)$Value, prob = 0.75, na.rm = TRUE)))
```



```{r}
#pdf("output.pdf", width = 8, height = 6)  # Open PDF device with specified size

library(viridis)
unique_continents <- unique(attribute$continent)
colors <- rainbow(length(unique_continents))
node_colors <- colors[match(attribute$continent, unique_continents)]


degrees <- degree(top, mode = "out")
# identify the top 10 nodes with the highest degree centrality
top_nodes <- order(degrees, decreasing = TRUE)[1:10]
# create a vector to store vertex labels
vertex_labels <- rep("", vcount(top))  # Initialize with empty labels for all nodes
# Assign labels to the top 10 nodes
vertex_labels[top_nodes] <- V(top)$Country[top_nodes]


dev.new()
pdf("service1.pdf", width = 8, height = 6)

# plotting the network with node colors based on coreness
plot(top, 
     vertex.size = degree(top, mode="in")*0.04, # reducing the node size 
     vertex.color = node_colors, 
     vertex.label = vertex_labels,
     vertex.label.cex = 0.6,
     vertex.label.dist = 0.5,
     vertex.label.color = "black", 
     edge.arrow.size = 0.1, 
     edge.curved = TRUE, 
     layout = as.matrix(cbind(attribute$Longitude.average., attribute$Latitude.average.)), asp = 0.8,
     edge.width = 0.001, 
     main = "Service Trade Network")

legend("topright", 
       legend = unique(attribute$continent),
       col = node_colors,
       pch = 16,
       title = "Continents")

graphics.off()

```



```{r}
summary(top)
mean(degree(top))
graph.density(top)
diameter(top)
reciprocity(top)
transitivity(top)
average.path.length(top)
```


```{r}
snet <- intergraph::asNetwork(top)
```

```{r}
#class(filtered_s$Ego)
#class(dis_net$dist)
```


```{r}
m1 <- ergm(snet ~ 
          edges +
          mutual +
          #triangles +
          nodecov("log_gdp") + # world bank
          absdiff("log_gdp") + 
          nodecov("Inflation_rate") + # world bank
          absdiff("Inflation_rate") + # world bank
          nodecov("RTA") +
          nodecov("area") + # world bank
          absdiff("area") +
          nodecov("FDI_net_inflows") + # world bank
          absdiff("FDI_net_inflows") + 
          nodecov("Net_barter_terms_of_trade_index") + # world bank
          absdiff("Net_barter_terms_of_trade_index") + 
          nodecov("GDP_per_capita_growth") + # world bank
          absdiff("GDP_per_capita_growth") +
          nodecov("Political_Stability") +
          nodematch("landlocked") +
          nodematch("langoff_1") +
          nodematch("continent") +
          #nodematch("con_BGD") )
          edgecov(dis_net, "dist") +
          edgecov(col_net, "colonization") +
          edgecov(co, "conttype"))
          #, control = control.ergm(MCMLE.maxit = 40, MCMC.interval = 20000))# world bank
          
```

```{r}
summary(m1)
```




```{r}
set.seed(240121)

m2 <- ergm(service ~ edges +
            mutual +
            triangles +
            nodecov("log_gdp") + # world bank
            absdiff("log_gdp") + # world bank
            nodecov("Inflation_rate") + # world bank
            absdiff("Inflation_rate") + # world bank
            nodecov("GDP_per_capita") + # world bank
            absdiff("GDP_per_capita") + # world bank
            nodematch("landlocked") +   #http://www.cepii.fr/CEPII/en/bdd_modele/download.asp?id=6
            nodematch("langoff_1") + # http://www.cepii.fr/CEPII/en/bdd_modele/download.asp?id=6
            nodematch("RTA") +
            nodecov("area") + # world bank
            absdiff("area") + # world bank
            nodecov("FDI_net_inflows") + # world bank
            absdiff("FDI_net_inflows") + # world bank
            nodematch("continent") +
            edgecov(col_net) +  #"colonization"
            edgecov(dis_net) +  #distance
            edgecov(co)   #"continguity"
                )

```


